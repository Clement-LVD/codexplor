---
title: "Citations Network of Internal Dependencies computed by codexplor"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Citations Network of Internal Dependencies computed by codexplor}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

This Vignette give a basic understanding of a `dataframe` of the `corpus.list` computed by some of the `codexplor` functions : a Citations Network of functions within programming project(s). This `data.frame` have additional classes `citations.network` and `internal.dependencies`.

## About the `citations.network` `dataframe` 
**Overall Considerations.** The `citations.network` class of `dataframe` is one of the cornerstones of `codexplor`, in order to made clusters of files before further processing, e.g., before to aggregate readability statistics for finding 'difficult-to-read' clusters. Some of the `codexplor` reporting protocols will add this `citations.network` class of `dataframe` into the main `corpus.list`, e.g., `codexplor::get_doc_network_from_project()`. 

> üéÅ The `citations.network` `dataframe` is an edgelist^[Edgelist is the one of the standard representation of a graph (https://igraph.org/r/doc/as_edgelist.html).] that symbolize the programming project as a document-to-document citations network : a network of documents that cite each others. 

A citations network have theoretical network properties, not covered here (e.g., a citations network is a directed network).

**`citations.network` of `internal.dependencies`**. Regarding the network computed by `codexplor` with programming files, a type of interesting `citations.network` is the network of `internal.dependencies` within a programming project computed by `codexplor::get_doc_network_from_project()`. In such a network, links start from the programming file that calls a function and point to the programming file where the function is defined.

### Network of `internal.dependencies`
One of the `dataframe` of the `corpus.list` have additional classes `citations.network` and `internal.dependencies`. In this network :

- Nodes are the programming files. 
- Edges go from the file that calls a function to the file where the function is defined.

`codexplor` default pattern are aimed to extract functions names from the files of a *programming* project (see next section). Thus, in a typical programming project :

- Nodes are files, supposed to be mostly - or only - functions ;
- ¬∞‚Üê Indegree of a file is "how many files are calling the function(s) defined in this file" ;
- ¬∞‚Üí Outdegree of a file is "how many functions are used by this file" ; 
- ‚ü≤ Auto-mentioning refear to 'recursivity' (`codexplor` default is to filter autolinks).

### Cascading matching operated by `compute_doc_network_from_corpus`
Given a `corpus.list` created with `construct_corpus`, `codexplor::compute_doc_network_from_corpus()` will try to perform a 'cascading matching' :

```{r table-cascading-matches, echo=FALSE}

match_2 <- data.frame(Step = c("‚è© `construct_corpus` is supposed to extract *functions names as a 1st matches*, from the files where these functions are defined)"
                    , "‚è© Transform the *1st matches* into a pattern and search for these patterns in the initial content, in order to compute a Citations Network with these 2nd matches")
             
             , Examples = c("e.g., have found 'Pier', 'pol' and 'jak' function names in 3 separate files" 
                          
,"e.g., a programming file is citing 'Pier', 'pol' and 'jak' and thus this file is linked to the files where we previously found these matches"))


rownames(match_2) <- c("1st matches" , "2nd matches" )

knitr::kable(match_2, row.names = T)


```

Thus, the 1st matches of `codexplor::construct_corpus` reveal some files that *defines* a function, and the 2nd matches of `compute_doc_network_from_corpus` show the files that used these functions.

### Function call that are non-supported during 2nd matches
Some way of writing a program are not fully supported during the 2nd matches, such as the instantiated Python methods, i.e. `obj.method()`.

**Python instantiated methods.** If we take this Python code sample, the 1st match is realized by `construct_corpus`, but we can't perform a 2nd match with `codexplor` for now.

```{r eval = F }
#  Consider the Python code herafter 
class A:
    def method(self):
        return "My custom method"
 # construct_corpus return 'method' as a 1stly matched function name

obj = A()
obj.method() # Return : 'My custom method'

# get_doc_network_from_project don't identify the 2nd match because of the prefix ("obj.")
```


### Filter undesired match
Junk nodes needs to be excluded from the network. Typical "false positive" matches are the lines where you use the name of another function in a message, e.g. `message("my_func() is deprecated. You should use this_function() instead)`. `get_doc_network_from_project` offer several parameters for dealing with your style of writing a program.


