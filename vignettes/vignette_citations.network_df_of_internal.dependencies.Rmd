---
title: "Citations Network of Internal Dependencies computed by codexplor"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Citations Network of Internal Dependencies computed by codexplor}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

This Vignette explain the `data.frame` with additional classes `citations.network` and `internal.dependencies`. This type of `data.frame` is the edgelist of a Citations Network of functions or files within programming project(s).  

## Network properties

### Overall Considerations : about the `citations.network` `data.frame` 
`codexplor::construct_corpus` protocols add a `citations.network` class of `data.frame` to the main `corpus.list`. 

This `citations.network` `data.frame` is an edgelist^[Edgelist is the one of the standard representation of a graph (https://igraph.org/r/doc/as_edgelist.html).] that symbolize the programming project as a document-to-document citations network : a network of documents, citing each others. 

`codexplor` offers several 'document' levels, e.g., the nodes of a `citations.network` `data.frame` could be the functions or the programming files of the corpus.

> A citations network have theoretical network properties, not covered here (e.g., a citations network is a directed network). 

### Networks of `internal.dependencies`
Some `data.frame` of the `corpus.list` have additional classes `citations.network` and `internal.dependencies` : the `files.network` and `functions.network` df. In these networks :

```{r echo=FALSE}
nett <- t(data.frame(Name= c("`files.network`", "`functions.network`" )
,  Nodes = c("Programming files", "Functions")
, Links = c("Start from a programming file that calls a function and point to the programming file where the function is defined", "start from a function that call another function and point to this 2nd function")
, Indegrees = c("°← How many files of the project(s) are calling the function(s) defined in this file", "°← How many functions of the project(s) are calling this function" )
, Outdegrees = c("°→ How many functions of the project(s) are used by this file", "°→ How many functions of the project(s) are used by this function")
, Automentioning = c("(`codexplor` default is to filter out autolinks within files)" ,"Recursivity")
) )



knitr::kable(nett)
```

## Technical details

### Cascading matching
Given a `corpus.list` created with `construct_corpus` a 'cascading matching' :

```{r table-cascading-matches, echo=FALSE}

match_2 <- data.frame(Step = c("⏩ `construct_corpus` firstly extract *functions names* from the files where these functions are defined"
                    , "⏩ Search for these patterns and compute a Citations Network")
             
             , Examples = c("e.g., have found 'Pier', 'pol' and 'jak' function names in 3 separate files" 
                          
,"e.g., a programming file is citing 'Pier(', 'pol(' and 'jak(' and thus this file is linked to the 3 files where these functions are defined or to these precise functions, depending on the desired level-of-depth"))


rownames(match_2) <- c("1st matches" , "2nd matches" )

knitr::kable(match_2, row.names = T)


```

Thus :

- the 1st matches of `codexplor::construct_corpus` will extract exposed functions names from files where these functions are *defined*, 
- and the 2nd matches show the files or the functions that *used* these functions. 

### Function call that are non-supported during 2nd matches
Some way of writing a program are not fully supported during the 2nd matches.

**Python instantiated methods.** If we take this Python code sample hereafter, the 1st match is realized by `construct_corpus`, but `codexplor` can't match the instantiated Python methods, i.e. `obj.method()`.

```{r eval = F }
#  Consider the Python code herafter 
class A:
    def method(self):
        return "My custom method"
 # construct_corpus return 'method' as a 1stly matched function name

obj = A()
obj.method() # Return : 'My custom method'

# construct_corpus don't identify the 2nd match because of the prefix ("obj.")
```


### Filter undesired match
`codexplor::construct_corpus` offer several parameters for dealing with your style of writing a program.

Junk nodes needs to be excluded from the returned networks. Typical "false positive" matches are the lines where you use the name of another function in a message, e.g. `message("my_func() is deprecated. You should use this_function() instead)`. For this type of false positive, `construct_corpus` offer the `exclude_quoted_content` parameter, in order to exclude quoted text from the matches and avoid this false positive case. Be aware that all the quoted text will be avoided, if you've included some - fancy - way of *call* a function as a quoted `character` chain.

      construct_corpus("~", languages = "R", exclude_quoted_content = TRUE)

See a sample dataviz' of a `files.network` in the [vignette of example of documents network](https://clement-lvd.github.io/codexplor/articles/vignette_analyse_citations_network_from_project.html)
