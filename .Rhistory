#' get_citations_network_from_df(df  ) #will return only the 2nd line (matching 'Bob')
#' get_citations_network_from_df(df,  keep_only_row_without_a_pattern = T ) #will return the lines (matching 'Bob')
#' @export
get_citations_network_from_df <- function(df
, content_varname = "content"
, pattern_varname = "first_match"
, prefix_for_regex_from_string = "" # text before the 1st match
,  suffix_for_regex_from_string = ""# add text after the 1st match
, keep_only_row_without_a_pattern  = TRUE
, varname_for_matches = "matches"
){
required_cols <- c(content_varname, pattern_varname)
missing_cols <- required_cols[!required_cols %in% names(df)]
if (length(missing_cols) > 0) {
stop(paste("Columns are missing in the data.frame :",
paste(missing_cols, collapse = ", ")))
}
# we will return a df.
dff <- df
dff$row_number <- seq_len(nrow(df))
### 1) construct a regex with the string
regexx_complete <- get_regex_from_vector(df[[pattern_varname]], prefix_for_regex_from_string, suffix_for_regex_from_string, fix_escaping = T  )
#we will retrieve this object and these var later
# 2) match every string
#  match every mention of our previous matches and returning a DF
fns_called_df <- str_extract_all_to_tidy_df(string =  dff[[content_varname]]
, pattern = regexx_complete
, row_number_colname = "row_number"
, matches_colname = varname_for_matches
, filter_unmatched = T)
# we have added row_number colname in both fns_called_df AND dff !
# 3) remove our pattern added (suffix or prefix) =>
fns_called_df[[varname_for_matches]] <- gsub(x = fns_called_df[[varname_for_matches]]
, pattern = paste0("^", prefix_for_regex_from_string), replacement = "")
fns_called_df[[varname_for_matches]]  <- gsub(x = fns_called_df[[varname_for_matches]]
, pattern = paste0(  suffix_for_regex_from_string, "$"), replacement = "")
#### 4) construct the network of func' ####
# reunite matches 1 and matches 2 =>
complete_network <- merge(fns_called_df, dff,
all.x = T # we preserve each 2nd match
, by = "row_number")
# lines will be duplicated if + than 1 match per line
# filter the network
# not empty first_match (func_defined) value indicate that this file mention his own match
# ('internal link', recursivity or func' definition) whereas other link refer to external link
if(keep_only_row_without_a_pattern){
row_to_exclude <- which(!is.na(complete_network[pattern_varname]))
if(length(row_to_exclude) > 0) complete_network <- complete_network[-row_to_exclude , ] }
return(complete_network)
}
get_citations_network_from_df(df  ) #will return only the 2nd line (matching 'Bob')
get_citations_network_from_df(df,  keep_only_row_without_a_pattern = T ) #will return the lines (matching 'Bob')
get_citations_network_from_df(df,  keep_only_row_without_a_pattern = F ) #will return the lines (matching 'Bob')
get_citations_network_from_df(df  ) #will return only the 2nd line (matching 'Bob')
test_that("Inclusion des autolinks si paramètre spécifié", {
df <- data.frame(
content = c(
"Cet article cite (Smith, 2021)",
"Référence à (Johnson, 2022)",
"Une autre citation (Smith, 2021)",
"Pas de citation ici"
),
first_match = c("Smith", "Johnson", "Smith", NA),
stringsAsFactors = FALSE
)
# On force l'inclusion des autolinks
result <- get_citations_network_from_df(df)
# Vérifie que l'autolink est présent cette fois
expect_true(any(result$from == result$to))
})
df <- data.frame(
content = c(
"Cet article cite (Smith, 2021)",
"Référence à (Johnson, 2022)",
"Une autre citation (Smith, 2021)",
"Pas de citation ici"
),
first_match = c("Smith", "Johnson", "Smith", NA),
stringsAsFactors = FALSE
)
# On force l'inclusion des autolinks
result <- get_citations_network_from_df(df)
result$from
result
df <- data.frame(
content = c(
"Cet article cite (Smith, 2021)",
"Référence à (Johnson, 2022)",
"Une autre citation (Smith, 2021)",
"Pas de citation ici"
),
first_match = c("Smith", "Johnson", "Smith", NA),
stringsAsFactors = FALSE
)
# On force l'inclusion des autolinks
result <- get_citations_network_from_df(df, keep_only_row_without_a_pattern = F)
# Vérifie que l'autolink est présent cette fois
expect_true(any(result$from == result$to))
result$from
# On force l'inclusion des autolinks
result <- get_citations_network_from_df(df, keep_only_row_without_a_pattern = F)
result
# Vérifie que l'autolink est présent cette fois
expect_true(any(result$matches == result$first_match))
test_that("Inclusion des autolinks si paramètre spécifié", {
df <- data.frame(
content = c(
"Cet article cite (Smith, 2021)",
"Référence à (Johnson, 2022)",
"Une autre citation (Smith, 2021)",
"Pas de citation ici"
),
first_match = c("Smith", "Johnson", "Smith", NA),
stringsAsFactors = FALSE
)
# On force l'inclusion des autolinks
result <- get_citations_network_from_df(df, keep_only_row_without_a_pattern = F)
# Vérifie que l'autolink est présent cette fois
expect_true(any(result$matches == result$first_match))
})
# Début des tests
test_that("Extract text and filter autolinks", {
df <- data.frame(
content = c(
"Cet article cite (Smith, 2021)",
"Référence à (Johnson, 2022)",
"Une autre citation (Smith, 2021)",
"Pas de citation ici"
),
first_match = c("Johnson", "Smith", "Doe", NA),
stringsAsFactors = FALSE
)
result <- get_citations_network_from_df(df)
# Vérifie que le résultat contient le réseau de citations attendu
expect_true(is.data.frame(result))
expect_gt(nrow(result), 0)
expect_equal(names(result), c("from", "to", "function", "content", "row_number"))
# Vérifie que l'autolink a bien été exclu par défaut
expect_false(any(result$from == result$to))
})
df <- data.frame(
content = c(
"Cet article cite (Smith, 2021)",
"Référence à (Johnson, 2022)",
"Une autre citation (Smith, 2021)",
"Pas de citation ici"
),
first_match = c("Johnson", "Smith", "Doe", NA),
stringsAsFactors = FALSE
)
result <- get_citations_network_from_df(df)
result
df <- data.frame(
content = c(
"Cet article cite (Smith, 2021)",
"Référence à (Johnson, 2022)",
"Une autre citation (Smith, 2021)",
"Pas de citation ici"
),
first_match = c( "Smith","Doe", "Johnson", NA),
stringsAsFactors = FALSE
)
result <- get_citations_network_from_df(df)
# Vérifie que le résultat contient le réseau de citations attendu
expect_true(is.data.frame(result))
expect_gt(nrow(result), 0)
nrow(result)
result
result <- get_citations_network_from_df(df)
result
df <- data.frame(
content = c(
"Cet article cite (Smith, 2021)",
"Référence à (Johnson, 2022)",
"Une autre citation (Smith, 2021)",
"Pas de citation ici"
),
first_match = c( "Smith","Doe", "Johnson", NA),
stringsAsFactors = FALSE
)
result <- get_citations_network_from_df(df)
result
# Début des tests
test_that("Extract text and filter autolinks", {
df <- data.frame(
content = c(
"Cet article cite (Smith, 2021)",
"Référence à (Johnson, 2022)",
"Une autre citation (Smith, 2021)",
"Pas de citation ici"
),
first_match = c("Doe",  "Smith","Johnson", NA),
stringsAsFactors = FALSE
)
result <- get_citations_network_from_df(df, )
# Vérifie que le résultat contient le réseau de citations attendu
expect_true(is.data.frame(result))
expect_gt(nrow(result), 0)
expect_equal(names(result), c("from", "to", "function", "content", "row_number"))
# Vérifie que l'autolink a bien été exclu par défaut
expect_false(any(result$from == result$to))
})
result <- get_citations_network_from_df(df, )
# Vérifie que le résultat contient le réseau de citations attendu
expect_true(is.data.frame(result))
expect_gt(nrow(result), 0)
result
result <- get_citations_network_from_df(df, )
df <- data.frame(
content = c(
"Cet article cite (Smith, 2021)",
"Référence à (Johnson, 2022)",
"Une autre citation (Smith, 2021)",
"Pas de citation ici"
),
first_match = c("Doe",  "Smith","Johnson", NA),
stringsAsFactors = FALSE
)
result <- get_citations_network_from_df(df, )
result
#'   \item{\code{first_match}}{The original pattern searched for, will be full of NA if keep_only_row_without_a_pattern is `TRUE`}
#' }
#'
#' @return A data frame with the extracted citations network.
#'
#' @examples
#' df <- data.frame(content = c("Citation (Bob, 2021)", "Another Bob sentence"), first_match = c("Bob" , NA))
#' get_citations_network_from_df(df  ) #will return only the 2nd line (matching 'Bob')
#' get_citations_network_from_df(df,  keep_only_row_without_a_pattern = F ) #will return the lines (matching 'Bob')
#' @export
get_citations_network_from_df <- function(df
, content_varname = "content"
, pattern_varname = "first_match"
, prefix_for_regex_from_string = "" # text before the 1st match
,  suffix_for_regex_from_string = ""# add text after the 1st match
, keep_only_row_without_a_pattern  = TRUE
, varname_for_matches = "matches"
){
required_cols <- c(content_varname, pattern_varname)
missing_cols <- required_cols[!required_cols %in% names(df)]
if (length(missing_cols) > 0) {
stop(paste("Columns are missing in the data.frame :",
paste(missing_cols, collapse = ", ")))
}
# we will return a df.
dff <- df
dff$row_number <- seq_len(nrow(df))
### 1) construct a regex with the string
regexx_complete <- get_regex_from_vector(df[[pattern_varname]], prefix_for_regex_from_string, suffix_for_regex_from_string, fix_escaping = T  )
#we will retrieve this object and these var later
# 2) match every string
#  match every mention of our previous matches and returning a DF
fns_called_df <- str_extract_all_to_tidy_df(string =  dff[[content_varname]]
, pattern = regexx_complete
, row_number_colname = "row_number"
, matches_colname = varname_for_matches
, filter_unmatched = T)
# we have added row_number colname in both fns_called_df AND dff !
# 3) remove our pattern added (suffix or prefix) =>
fns_called_df[[varname_for_matches]] <- gsub(x = fns_called_df[[varname_for_matches]]
, pattern = paste0("^", prefix_for_regex_from_string), replacement = "")
fns_called_df[[varname_for_matches]]  <- gsub(x = fns_called_df[[varname_for_matches]]
, pattern = paste0(  suffix_for_regex_from_string, "$"), replacement = "")
#### 4) construct the network of func' ####
# reunite matches 1 and matches 2 =>
complete_network <- merge(fns_called_df, dff,
all.x = T # we preserve each 2nd match
, by = "row_number")
# lines will be duplicated if + than 1 match per line
# filter the network
# not empty first_match (func_defined) value indicate that this file mention his own match
# ('internal link', recursivity or func' definition) whereas other link refer to external link
if(keep_only_row_without_a_pattern){
row_to_exclude <- which(!is.na(complete_network[pattern_varname]))
if(length(row_to_exclude) > 0) complete_network <- complete_network[-row_to_exclude , ] }
return(complete_network)
}
result <- get_citations_network_from_df(df, )
result
result <- get_citations_network_from_df(df )
result
result <- get_citations_network_from_df(df, keep_only_row_without_a_pattern = F )
# Vérifie que le résultat contient le réseau de citations attendu
expect_true(is.data.frame(result))
expect_gt(nrow(result), 0)
expect_equal(names(result), c("from", "to", "function", "content", "row_number"))
complete_network
expect_equal(names(result), c("row_number", "matches",  "content", "first_match"))
test_that("Inclusion des autolinks si paramètre spécifié", {
df <- data.frame(
content = c(
"Cet article cite (Smith, 2021)",
"Référence à (Johnson, 2022)",
"Une autre citation (Smith, 2021)",
"Pas de citation ici"
),
first_match = c("Smith", "Johnson", "Smith", NA),
stringsAsFactors = FALSE
)
# On force l'inclusion des autolinks
result <- get_citations_network_from_df(df, keep_only_row_without_a_pattern = F)
# Vérifie que l'autolink est présent cette fois
expect_true(any(result$matches == result$first_match))
})
test_that("Aucun résultat si tous les liens sont des autolinks", {
df <- data.frame(
content = c(
"Cet article cite (Smith, 2021)",
"Référence à (Johnson, 2022)"
),
first_match = c("Smith, 2021", "Johnson, 2022"),
stringsAsFactors = FALSE
)
result <- get_citations_network_from_df(df)
# Vérifie que le résultat est un data.frame vide
expect_true(is.data.frame(result))
expect_equal(nrow(result), 0)
})
test_that("Paramètres personnalisés pour les colonnes", {
df <- data.frame(
texte = c(
"Cet article cite (Smith, 2021)",
"Référence à (Johnson, 2022)"
),
motif = c("Smith, 2021", "Johnson, 2022"),
stringsAsFactors = FALSE
)
result <- get_citations_network_from_df(
df,
content_varname = "texte",
pattern_varname = "motif"
)
expect_true(is.data.frame(result))
expect_gt(nrow(result), 0)
})
df <- data.frame(
texte = c(
"Cet article cite (Smith, 2021)",
"Référence à (Johnson, 2022)"
),
motif = c("Smith, 2021", "Johnson, 2022"),
stringsAsFactors = FALSE
)
result <- get_citations_network_from_df(
df,
content_varname = "texte",
pattern_varname = "motif"
)
expect_true(is.data.frame(result))
result
result <- get_citations_network_from_df(keep_only_row_without_a_pattern = F,
df,
content_varname = "texte",
pattern_varname = "motif"
)
expect_true(is.data.frame(result))
expect_gt(nrow(result), 0)
#'   - `local_file_ext`: The typical file extension for the language + a $ (regex for end of line).
#'
#' @details
#' This function supports multiple programming languages in a single call.
#' Language names are case-insensitive.
#'
#' @examples
#' # fn_def <-function_def_regex_by_language("Python", "R")
#' # fn_def <- function_def_regex_by_language("Go", "C", "JavaScript")
#' @export
function_def_regex_by_language <- function(...) {
#### 1) define function regex => core behavior is catching func' names ####
functions_def_by_language_regex_pattern <- list(
R = list(
fn_regex = "(^| \\.|\\b)([A-Za-z0-9_\\.]+)(?=\\s*(?:<-)\\s*function)",
file_extension = ".R"
, pattern_to_exlude = "\\.Rcheck|test-"
),
Python = list(
fn_regex = "^\\s*def\\s+([\\w_]+)\\s*\\(",
file_extension = ".py"
, pattern_to_exlude = ""),
JavaScript = list(
fn_regex = "^\\s*function\\s+([\\w_]+)\\s*\\(",
file_extension = ".js"
, pattern_to_exlude = ""
),
Java = list(
fn_regex = "^\\s*(public|private|protected)?\\s*\\w+\\s+([\\w_]+)\\s*\\(",
file_extension = ".java"
, pattern_to_exlude = ""
),
C = list(
fn_regex = "^\\s*\\w+\\s+([\\w_]+)\\s*\\(",
file_extension = ".c"
, pattern_to_exlude = ""
),
Cpp = list(
fn_regex = "^\\s*\\w+(<.*>)?\\s+([\\w_]+)\\s*\\(",
file_extension = ".cpp"
, pattern_to_exlude = ""
),
Go = list(
fn_regex = "^\\s*func\\s+([\\w_]+)\\s*\\(",
file_extension = ".go"
, pattern_to_exlude = ""
)
)
#### 2) return this list into a dataframe ####
languages <- tolower( c(...))  # Récupère tous les arguments passés
available_languages <- tolower(names(functions_def_by_language_regex_pattern))
non_available <- languages[!languages %in% available_languages]
if(length(non_available) > 1) {
stop("Unsupported language(s) (" , paste0(collapse = ", ", non_available), ") !\n Available languages => ",
paste(names(functions_def_by_language_regex_pattern), collapse = ", "))
}
returned <- functions_def_by_language_regex_pattern[available_languages %in% languages]
lang_df <- do.call(rbind, lapply(names(returned), function(lang) {
data.frame(language = lang,
fn_regex = returned[[lang]]$fn_regex,
file_ext = returned[[lang]]$file_extension,
pattern_to_exclude = returned[[lang]]$pattern_to_exlude
,stringsAsFactors = FALSE)
}))
# RETURN A LIST IF NO ARG PASSED !
if(is.null(lang_df)){return(functions_def_by_language_regex_pattern)}
lang_df$local_file_ext <- paste0(lang_df$file_ext, "$" )
return(lang_df )
}
#' Retrieve function definition regex patterns by programming language
#'
#' This function returns a df with regex patterns and file extensions associated with function definitions
#' for one or more specified programming languages.
#'
#' @param ... One or more programming language names (character strings).
#'
#' @return A dataframe where each row corresponds to a language and contains:
#'   -  `language`: The name (e.g., 'R')
#'   - `fn_regex`: The regex pattern used to detect function definitions in this language.
#'   - `file_ext`: The typical file extension for the language.
#'   - `local_file_ext`: The typical file extension for the language + a $ (regex for end of line).
#'
#' @details
#' This function supports multiple programming languages in a single call.
#' Language names are case-insensitive.
#'
#' @examples
#' # fn_def <-function_def_regex_by_language("Python", "R")
#' # fn_def <- function_def_regex_by_language("Go", "C", "JavaScript")
#' @export
function_def_regex_by_language <- function(...) {
#### 1) define function regex => core behavior is catching func' names ####
functions_def_by_language_regex_pattern <- list(
R = list(
fn_regex = "(^| \\.|\\b)([A-Za-z0-9_\\.]+)(?=\\s*(?:<-)\\s*function)",
file_extension = ".R"
, pattern_to_exlude = "\\.Rcheck|test-"
),
Python = list(
fn_regex = "^\\s*def\\s+([\\w_]+)\\s*\\(",
file_extension = ".py"
, pattern_to_exlude = ""),
JavaScript = list(
fn_regex = "^\\s*function\\s+([\\w_]+)\\s*\\(",
file_extension = ".js"
, pattern_to_exlude = ""
),
Java = list(
fn_regex = "^\\s*(public|private|protected)?\\s*\\w+\\s+([\\w_]+)\\s*\\(",
file_extension = ".java"
, pattern_to_exlude = ""
),
C = list(
fn_regex = "^\\s*\\w+\\s+([\\w_]+)\\s*\\(",
file_extension = ".c"
, pattern_to_exlude = ""
),
Cpp = list(
fn_regex = "^\\s*\\w+(<.*>)?\\s+([\\w_]+)\\s*\\(",
file_extension = ".cpp"
, pattern_to_exlude = ""
),
Go = list(
fn_regex = "^\\s*func\\s+([\\w_]+)\\s*\\(",
file_extension = ".go"
, pattern_to_exlude = ""
)
)
#### 2) return this list into a dataframe ####
languages <- tolower( c(...))  # Récupère tous les arguments passés
available_languages <- tolower(names(functions_def_by_language_regex_pattern))
non_available <- languages[!languages %in% available_languages]
if(length(non_available) > 1) {
stop("Unsupported language(s) (" , paste0(collapse = ", ", non_available), ") !\n Available languages => ",
paste(names(functions_def_by_language_regex_pattern), collapse = ", "))
}
returned <- functions_def_by_language_regex_pattern[available_languages %in% languages]
lang_df <- do.call(rbind, lapply(names(returned), function(lang) {
data.frame(language = lang,
fn_regex = returned[[lang]]$fn_regex,
file_ext = returned[[lang]]$file_extension,
pattern_to_exclude = returned[[lang]]$pattern_to_exlude
,stringsAsFactors = FALSE)
}))
# RETURN A LIST IF NO ARG PASSED !
if(is.null(lang_df)){return(functions_def_by_language_regex_pattern)}
lang_df$local_file_ext <- paste0(lang_df$file_ext, "$" )
return(lang_df )
}
function_def_regex_by_language()
names(function_def_regex_by_language()
)
codexplor::function_def_regex_by_language()
pkgdown::build_reference()
devtools::build_vignettes()
