expanded_df <- df # df with same n_row than the original one
expanded_df$row_num <- 1:nrow(expanded_df) # a valid line_number
expanded_df$list_of_matched_txt <- complete_result  # by default initialize the col' "to" (here we write a list in this col')
# expanded_df$list_of_matched_txt <- lapply(expanded_df$list_of_matched_txt, function(x) if (is.null(x)) integer(0) else x)
if(max_lines_to_create == 0){expanded_df$list_of_matched_txt <- NA}
# Fill the "list_of_matched_txt" col' in order to prevent some bug if there is no result (no match)
# Unnest with base R
flattened_df <- data.frame(row_num = rep(expanded_df$row_num # We REP each row until unnesting the list =>
, sapply(expanded_df$list_of_matched_txt, length)),
# sapply(expanded_df$matches, length) give length of each sublist, used for repeating value.
values = unlist(expanded_df$list_of_matched_txt)) # and unlist(expanded_df$matches) give a raw vector.
colnames(flattened_df) <- c("row_num",   returned_col_name ) #  custom colnames provided by the user
# the df will have eventually a lines addition. Equivalent of :
# expanded_df <- tidyr::unnest(data = expanded_df, cols = !!returned_col_name, keep_empty = keep_empty_results) # to
expanded_df <- merge(expanded_df, flattened_df, by = "row_num", all = T ) # adding these lines to expanded_df
# eject lines with no match (optionnal)
if(!keep_empty_results){expanded_df <- expanded_df[which(!is.na(expanded_df[[returned_col_name]]) ) , ]}
# df_new <- do.call(rbind, Map(cbind, id = df$id, df$valeurs))
# rownames(df_new) <- NULL  # Nettoyage des noms de lignes
# or we have to reduce the number of lines and join to the user dataframe
# expanded_df <- unique(expanded_df)
return(expanded_df)
}
extract_txt_from_df_vars(df, "World|Hello", cols_for_searching_text = 1:2)
roxygen2::roxygenize()
get_text_network_from_files <- function(functions_folder_path = getwd()
, filter_match_by_nchar = 3
, filter_func_name_not_in = "" #c("server")
,  suffix_for_regex_from_the_text = ""
, filter_matched_line = T
, filter_func_definition = T
, filter_ego_link = T
){
####1) Get content from R files ####
# With the default regex of srch_pattern_in_files_get_df, fn_network indicate where the func' are defined
fn_network <-  srch_pattern_in_files_get_df(path_main_folder = functions_folder_path
, file_path_col_name = "file_path", content_col_name = "content", extracted_prefix_col_name = "func_defined")
fn_defined <- unique(fn_network$func_defined)
#we have the files where each func is defined
fn_defined <- fn_defined[!fn_defined %in% filter_func_name_not_in]
#### 2) Constructing regex ####
regexx <- fn_defined[!is.na(fn_defined)]
# with name of func we will construct a regex pattern, passed to extract_txt_from_df_vars
# filter result according to nchar parameter =>
regexx <- regexx[which(nchar(regexx) > filter_match_by_nchar)]
# optionnally add a suffix (such as a filter from the user)
regexx <- paste0(regexx, suffix_for_regex_from_the_text)
# made a single giga-regex and clean it from unescaped chars
regexx_complete <- paste0(regexx, collapse = "|")
# clean undesired char
regexx_complete <- escape_unescaped_chars(regexx_complete)
#### 3) get network of func' ####
# Extract text again from the content, again (but dynamic regex)
complete_network <- extract_txt_from_df_vars(df = fn_network, regex_extract_txt = regexx_complete
, cols_for_searching_text = "content", returned_col_name = "called_name", keep_empty_results = F) # matches are func' CALLED
#### 4) filter the network ####
# we have the ego-network remaining from where the file is defined, counting as a link for now
if(filter_matched_line){complete_network <- complete_network[ which(!is.na(complete_network["called_name"])) , ] }
# not empty func_defined value indicate that this is a function definition (from the begining => ego-link or even recursivity)
if(filter_func_definition){complete_network <- complete_network[ which(is.na(complete_network["func_defined"])) , ] }
origines_files <- unique(fn_network[which(!is.na(fn_network$func_defined)), c("func_defined","file_path", "content")])
colnames( origines_files  ) <- c("function", "defined_in", "definition_content")
complete_network <- merge( complete_network, origines_files, by.x = "called_name", by.y = "function", all.x = TRUE)
returned_network <- complete_network[, c("file_path", "defined_in", "called_name", "line_number", "content",  "definition_content")]
if(filter_ego_link){returned_network <- returned_network[ which( returned_network["file_path"] != returned_network["defined_in"]) , ] }
return(returned_network)
}
test <- get_text_network_from_files()
View(test)
get_text_network_from_files <- function(functions_folder_path = getwd()
, filter_match_by_nchar = 3
, filter_func_name_not_in = "" #c("server")
,  suffix_for_regex_from_the_text = "(?<!test-)"
, filter_matched_line = T
, filter_func_definition = T
, filter_ego_link = T
){
####1) Get content from R files ####
# With the default regex of srch_pattern_in_files_get_df, fn_network indicate where the func' are defined
fn_network <-  srch_pattern_in_files_get_df(path_main_folder = functions_folder_path
, file_path_col_name = "file_path", content_col_name = "content", extracted_prefix_col_name = "func_defined")
fn_defined <- unique(fn_network$func_defined)
#we have the files where each func is defined
fn_defined <- fn_defined[!fn_defined %in% filter_func_name_not_in]
#### 2) Constructing regex ####
regexx <- fn_defined[!is.na(fn_defined)]
# with name of func we will construct a regex pattern, passed to extract_txt_from_df_vars
# filter result according to nchar parameter =>
regexx <- regexx[which(nchar(regexx) > filter_match_by_nchar)]
# optionnally add a suffix (such as a filter from the user)
regexx <- paste0(regexx, suffix_for_regex_from_the_text)
# made a single giga-regex and clean it from unescaped chars
regexx_complete <- paste0(regexx, collapse = "|")
# clean undesired char
regexx_complete <- escape_unescaped_chars(regexx_complete)
#### 3) get network of func' ####
# Extract text again from the content, again (but dynamic regex)
complete_network <- extract_txt_from_df_vars(df = fn_network, regex_extract_txt = regexx_complete
, cols_for_searching_text = "content", returned_col_name = "called_name", keep_empty_results = F) # matches are func' CALLED
#### 4) filter the network ####
# we have the ego-network remaining from where the file is defined, counting as a link for now
if(filter_matched_line){complete_network <- complete_network[ which(!is.na(complete_network["called_name"])) , ] }
# not empty func_defined value indicate that this is a function definition (from the begining => ego-link or even recursivity)
if(filter_func_definition){complete_network <- complete_network[ which(is.na(complete_network["func_defined"])) , ] }
origines_files <- unique(fn_network[which(!is.na(fn_network$func_defined)), c("func_defined","file_path", "content")])
colnames( origines_files  ) <- c("function", "defined_in", "definition_content")
complete_network <- merge( complete_network, origines_files, by.x = "called_name", by.y = "function", all.x = TRUE)
returned_network <- complete_network[, c("file_path", "defined_in", "called_name", "line_number", "content",  "definition_content")]
if(filter_ego_link){returned_network <- returned_network[ which( returned_network["file_path"] != returned_network["defined_in"]) , ] }
return(returned_network)
}
View(test)
test <- get_text_network_from_files()
get_text_network_from_files <- function(functions_folder_path = getwd()
, filter_match_by_nchar = 3
, filter_func_name_not_in = "" #c("server")
,  suffix_for_regex_from_the_text = ""
,prefix_for_regex_from_the_text = "(?<!test-)"
, filter_matched_line = T
, filter_func_definition = T
, filter_ego_link = T
){
####1) Get content from R files ####
# With the default regex of srch_pattern_in_files_get_df, fn_network indicate where the func' are defined
fn_network <-  srch_pattern_in_files_get_df(path_main_folder = functions_folder_path
, file_path_col_name = "file_path", content_col_name = "content", extracted_prefix_col_name = "func_defined")
fn_defined <- unique(fn_network$func_defined)
#we have the files where each func is defined
fn_defined <- fn_defined[!fn_defined %in% filter_func_name_not_in]
#### 2) Constructing regex ####
regexx <- fn_defined[!is.na(fn_defined)]
# with name of func we will construct a regex pattern, passed to extract_txt_from_df_vars
# filter result according to nchar parameter =>
regexx <- regexx[which(nchar(regexx) > filter_match_by_nchar)]
# optionnally add a suffix (such as a filter from the user)
regexx <- paste0(prefix_for_regex_from_the_text, regexx, suffix_for_regex_from_the_text)
# made a single giga-regex and clean it from unescaped chars
regexx_complete <- paste0(regexx, collapse = "|")
# clean undesired char
regexx_complete <- escape_unescaped_chars(regexx_complete)
#### 3) get network of func' ####
# Extract text again from the content, again (but dynamic regex)
complete_network <- extract_txt_from_df_vars(df = fn_network, regex_extract_txt = regexx_complete
, cols_for_searching_text = "content", returned_col_name = "called_name", keep_empty_results = F) # matches are func' CALLED
#### 4) filter the network ####
# we have the ego-network remaining from where the file is defined, counting as a link for now
if(filter_matched_line){complete_network <- complete_network[ which(!is.na(complete_network["called_name"])) , ] }
# not empty func_defined value indicate that this is a function definition (from the begining => ego-link or even recursivity)
if(filter_func_definition){complete_network <- complete_network[ which(is.na(complete_network["func_defined"])) , ] }
origines_files <- unique(fn_network[which(!is.na(fn_network$func_defined)), c("func_defined","file_path", "content")])
colnames( origines_files  ) <- c("function", "defined_in", "definition_content")
complete_network <- merge( complete_network, origines_files, by.x = "called_name", by.y = "function", all.x = TRUE)
returned_network <- complete_network[, c("file_path", "defined_in", "called_name", "line_number", "content",  "definition_content")]
if(filter_ego_link){returned_network <- returned_network[ which( returned_network["file_path"] != returned_network["defined_in"]) , ] }
return(returned_network)
}
test <- get_text_network_from_files()
View(test)
get_text_network_from_files <- function(functions_folder_path = getwd()
, filter_match_by_nchar = 3
, filter_func_name_not_in = "" #c("server")
,  suffix_for_regex_from_the_text = ""
,prefix_for_regex_from_the_text = ""
, filter_matched_line = T
, filter_func_definition = T
, filter_ego_link = T
){
####1) Get content from R files ####
# With the default regex of srch_pattern_in_files_get_df, fn_network indicate where the func' are defined
fn_network <-  srch_pattern_in_files_get_df(path_main_folder = functions_folder_path
, file_path_col_name = "file_path", content_col_name = "content", extracted_prefix_col_name = "func_defined")
fn_defined <- unique(fn_network$func_defined)
#we have the files where each func is defined
fn_defined <- fn_defined[!fn_defined %in% filter_func_name_not_in]
#### 2) Constructing regex ####
regexx <- fn_defined[!is.na(fn_defined)]
# with name of func we will construct a regex pattern, passed to extract_txt_from_df_vars
# filter result according to nchar parameter =>
regexx <- regexx[which(nchar(regexx) > filter_match_by_nchar)]
# optionnally add a suffix (such as a filter from the user)
regexx <- paste0(prefix_for_regex_from_the_text, regexx, suffix_for_regex_from_the_text)
# made a single giga-regex and clean it from unescaped chars
regexx_complete <- paste0(regexx, collapse = "|")
# clean undesired char
regexx_complete <- escape_unescaped_chars(regexx_complete)
#### 3) get network of func' ####
# Extract text again from the content, again (but dynamic regex)
complete_network <- extract_txt_from_df_vars(df = fn_network, regex_extract_txt = regexx_complete
, cols_for_searching_text = "content", returned_col_name = "called_name", keep_empty_results = F) # matches are func' CALLED
#### 4) filter the network ####
# we have the ego-network remaining from where the file is defined, counting as a link for now
if(filter_matched_line){complete_network <- complete_network[ which(!is.na(complete_network["called_name"])) , ] }
# not empty func_defined value indicate that this is a function definition (from the begining => ego-link or even recursivity)
if(filter_func_definition){complete_network <- complete_network[ which(is.na(complete_network["func_defined"])) , ] }
origines_files <- unique(fn_network[which(!is.na(fn_network$func_defined)), c("func_defined","file_path", "content")])
colnames( origines_files  ) <- c("function", "defined_in", "definition_content")
complete_network <- merge( complete_network, origines_files, by.x = "called_name", by.y = "function", all.x = TRUE)
returned_network <- complete_network[, c("file_path", "defined_in", "called_name", "line_number", "content",  "definition_content")]
if(filter_ego_link){returned_network <- returned_network[ which( returned_network["file_path"] != returned_network["defined_in"]) , ] }
return(returned_network)
}
test <- get_text_network_from_files()
merge(complete_network, origines_files, by.x = "called_name", by.y = "function", all.x = TRUE)
complete_network
grep(x = returned_network$file_path, pattern =  regex_to_exclude_files_path)
grep(x = c('abc', "def"), pattern =  "a")
grep(x = c('abc', "def"), pattern =  "d")
grep(x = c('abc', "def"), pattern =  "")
grep(x = c('abc', "def"), pattern =  NA)
grep(x = c('abc', "def"), pattern =  "")
returned_network[-grep(x = returned_network$file_path, pattern =  regex_to_exclude_files_path), ]
get_text_network_from_files <- function(functions_folder_path = getwd()
, filter_match_by_nchar = 3
, filter_func_name_not_in = "" #c("server")
,  suffix_for_regex_from_the_text = ""
,prefix_for_regex_from_the_text = ""
, regex_to_exclude_files_path = "test-"
, filter_matched_line = T
, filter_func_definition = T
, filter_ego_link = T
){
####1) Get content from R files ####
# With the default regex of srch_pattern_in_files_get_df, fn_network indicate where the func' are defined
fn_network <-  srch_pattern_in_files_get_df(path_main_folder = functions_folder_path
, file_path_col_name = "file_path", content_col_name = "content", extracted_prefix_col_name = "func_defined")
fn_defined <- unique(fn_network$func_defined)
#we have the files where each func is defined
fn_defined <- fn_defined[!fn_defined %in% filter_func_name_not_in]
#### 2) Constructing regex ####
regexx <- fn_defined[!is.na(fn_defined)]
# with name of func we will construct a regex pattern, passed to extract_txt_from_df_vars
# filter result according to nchar parameter =>
regexx <- regexx[which(nchar(regexx) > filter_match_by_nchar)]
# optionnally add a suffix (such as a filter from the user)
regexx <- paste0(prefix_for_regex_from_the_text, regexx, suffix_for_regex_from_the_text)
# made a single giga-regex and clean it from unescaped chars
regexx_complete <- paste0(regexx, collapse = "|")
# clean undesired char
regexx_complete <- escape_unescaped_chars(regexx_complete)
#### 3) get network of func' ####
# Extract text again from the content, again (but dynamic regex)
complete_network <- extract_txt_from_df_vars(df = fn_network, regex_extract_txt = regexx_complete
, cols_for_searching_text = "content", returned_col_name = "called_name", keep_empty_results = F) # matches are func' CALLED
#### 4) filter the network ####
# we have the ego-network remaining from where the file is defined, counting as a link for now
if(filter_matched_line){complete_network <- complete_network[ which(!is.na(complete_network["called_name"])) , ] }
# not empty func_defined value indicate that this is a function definition (from the begining => ego-link or even recursivity)
if(filter_func_definition){complete_network <- complete_network[ which(is.na(complete_network["func_defined"])) , ] }
# take again original files for adding the path where a func' is defined
origines_files <- unique(fn_network[which(!is.na(fn_network$func_defined)), c("func_defined","file_path", "content")])
colnames( origines_files ) <- c("function", "defined_in", "definition_content")
complete_network <- merge(complete_network, origines_files, by.x = "called_name", by.y = "function", all.x = TRUE)
returned_network <- complete_network[, c("file_path", "defined_in", "called_name", "line_number", "content",  "definition_content")]
if(filter_ego_link){returned_network <- returned_network[ which( returned_network["file_path"] != returned_network["defined_in"]) , ] }
returned_network <- returned_network[-grep(x = returned_network$file_path, pattern =  regex_to_exclude_files_path), ]
return(returned_network)
}
test <- get_text_network_from_files()
View(test)
get_text_network_from_files <- function(functions_folder_path = getwd()
, filter_match_by_nchar = 3
, filter_func_name_not_in = "" #c("server")
,  suffix_for_regex_from_the_text = ""
,prefix_for_regex_from_the_text = ""
, regex_to_exclude_files_path = ""#"test-"
, filter_matched_line = T
, filter_func_definition = T
, filter_ego_link = T
){
####1) Get content from R files ####
# With the default regex of srch_pattern_in_files_get_df, fn_network indicate where the func' are defined
fn_network <-  srch_pattern_in_files_get_df(path_main_folder = functions_folder_path
, file_path_col_name = "file_path", content_col_name = "content", extracted_prefix_col_name = "func_defined")
fn_defined <- unique(fn_network$func_defined)
#we have the files where each func is defined
fn_defined <- fn_defined[!fn_defined %in% filter_func_name_not_in]
#### 2) Constructing regex ####
regexx <- fn_defined[!is.na(fn_defined)]
# with name of func we will construct a regex pattern, passed to extract_txt_from_df_vars
# filter result according to nchar parameter =>
regexx <- regexx[which(nchar(regexx) > filter_match_by_nchar)]
# optionnally add a suffix (such as a filter from the user)
regexx <- paste0(prefix_for_regex_from_the_text, regexx, suffix_for_regex_from_the_text)
# made a single giga-regex and clean it from unescaped chars
regexx_complete <- paste0(regexx, collapse = "|")
# clean undesired char
regexx_complete <- escape_unescaped_chars(regexx_complete)
#### 3) get network of func' ####
# Extract text again from the content, again (but dynamic regex)
complete_network <- extract_txt_from_df_vars(df = fn_network, regex_extract_txt = regexx_complete
, cols_for_searching_text = "content", returned_col_name = "called_name", keep_empty_results = F) # matches are func' CALLED
#### 4) filter the network ####
# we have the ego-network remaining from where the file is defined, counting as a link for now
if(filter_matched_line){complete_network <- complete_network[ which(!is.na(complete_network["called_name"])) , ] }
# not empty func_defined value indicate that this is a function definition (from the begining => ego-link or even recursivity)
if(filter_func_definition){complete_network <- complete_network[ which(is.na(complete_network["func_defined"])) , ] }
# take again original files for adding the path where a func' is defined
origines_files <- unique(fn_network[which(!is.na(fn_network$func_defined)), c("func_defined","file_path", "content")])
colnames( origines_files ) <- c("function", "defined_in", "definition_content")
complete_network <- merge(complete_network, origines_files, by.x = "called_name", by.y = "function", all.x = TRUE)
returned_network <- complete_network[, c("file_path", "defined_in", "called_name", "line_number", "content",  "definition_content")]
if(filter_ego_link){returned_network <- returned_network[ which( returned_network["file_path"] != returned_network["defined_in"]) , ] }
returned_network <- returned_network[-grep(x = returned_network$file_path, pattern =  regex_to_exclude_files_path), ]
return(returned_network)
}
test <- get_text_network_from_files()
returned_network$file_path
get_text_network_from_files <- function(functions_folder_path = getwd()
, filter_match_by_nchar = 3
, filter_func_name_not_in = "" #c("server")
,  suffix_for_regex_from_the_text = ""
,prefix_for_regex_from_the_text = ""
, regex_to_exclude_files_path = ""#"test-"
, filter_matched_line = T
, filter_func_definition = T
, filter_ego_link = T
){
####1) Get content from R files ####
# With the default regex of srch_pattern_in_files_get_df, fn_network indicate where the func' are defined
fn_network <-  srch_pattern_in_files_get_df(path_main_folder = functions_folder_path
, file_path_col_name = "file_path", content_col_name = "content", extracted_prefix_col_name = "func_defined")
fn_defined <- unique(fn_network$func_defined)
#we have the files where each func is defined
fn_defined <- fn_defined[!fn_defined %in% filter_func_name_not_in]
#### 2) Constructing regex ####
regexx <- fn_defined[!is.na(fn_defined)]
# with name of func we will construct a regex pattern, passed to extract_txt_from_df_vars
# filter result according to nchar parameter =>
regexx <- regexx[which(nchar(regexx) > filter_match_by_nchar)]
# optionnally add a suffix (such as a filter from the user)
regexx <- paste0(prefix_for_regex_from_the_text, regexx, suffix_for_regex_from_the_text)
# made a single giga-regex and clean it from unescaped chars
regexx_complete <- paste0(regexx, collapse = "|")
# clean undesired char
regexx_complete <- escape_unescaped_chars(regexx_complete)
#### 3) get network of func' ####
# Extract text again from the content, again (but dynamic regex)
complete_network <- extract_txt_from_df_vars(df = fn_network, regex_extract_txt = regexx_complete
, cols_for_searching_text = "content", returned_col_name = "called_name", keep_empty_results = F) # matches are func' CALLED
#### 4) filter the network ####
# we have the ego-network remaining from where the file is defined, counting as a link for now
if(filter_matched_line){complete_network <- complete_network[ which(!is.na(complete_network["called_name"])) , ] }
# not empty func_defined value indicate that this is a function definition (from the begining => ego-link or even recursivity)
if(filter_func_definition){complete_network <- complete_network[ which(is.na(complete_network["func_defined"])) , ] }
# take again original files for adding the path where a func' is defined
origines_files <- unique(fn_network[which(!is.na(fn_network$func_defined)), c("func_defined","file_path", "content")])
colnames( origines_files ) <- c("function", "defined_in", "definition_content")
complete_network <- merge(complete_network, origines_files, by.x = "called_name", by.y = "function", all.x = TRUE)
returned_network <- complete_network[, c("file_path", "defined_in", "called_name", "line_number", "content",  "definition_content")]
if(filter_ego_link){returned_network <- returned_network[ which( returned_network["file_path"] != returned_network["defined_in"]) , ] }
returned_network <- returned_network[-grep(x = returned_network$file_path, pattern =  regex_to_exclude_files_path), ]
return(returned_network)
}
test <- get_text_network_from_files()
get_text_network_from_files <- function(functions_folder_path = getwd()
, filter_match_by_nchar = 3
, filter_func_name_not_in = "" #c("server")
,  suffix_for_regex_from_the_text = ""
,prefix_for_regex_from_the_text = ""
, regex_to_exclude_files_path = "test-"
, filter_matched_line = T
, filter_func_definition = T
, filter_ego_link = T
){
####1) Get content from R files ####
# With the default regex of srch_pattern_in_files_get_df, fn_network indicate where the func' are defined
fn_network <-  srch_pattern_in_files_get_df(path_main_folder = functions_folder_path
, file_path_col_name = "file_path", content_col_name = "content", extracted_prefix_col_name = "func_defined")
fn_defined <- unique(fn_network$func_defined)
#we have the files where each func is defined
fn_defined <- fn_defined[!fn_defined %in% filter_func_name_not_in]
#### 2) Constructing regex ####
regexx <- fn_defined[!is.na(fn_defined)]
# with name of func we will construct a regex pattern, passed to extract_txt_from_df_vars
# filter result according to nchar parameter =>
regexx <- regexx[which(nchar(regexx) > filter_match_by_nchar)]
# optionnally add a suffix (such as a filter from the user)
regexx <- paste0(prefix_for_regex_from_the_text, regexx, suffix_for_regex_from_the_text)
# made a single giga-regex and clean it from unescaped chars
regexx_complete <- paste0(regexx, collapse = "|")
# clean undesired char
regexx_complete <- escape_unescaped_chars(regexx_complete)
#### 3) get network of func' ####
# Extract text again from the content, again (but dynamic regex)
complete_network <- extract_txt_from_df_vars(df = fn_network, regex_extract_txt = regexx_complete
, cols_for_searching_text = "content", returned_col_name = "called_name", keep_empty_results = F) # matches are func' CALLED
#### 4) filter the network ####
# we have the ego-network remaining from where the file is defined, counting as a link for now
if(filter_matched_line){complete_network <- complete_network[ which(!is.na(complete_network["called_name"])) , ] }
# not empty func_defined value indicate that this is a function definition (from the begining => ego-link or even recursivity)
if(filter_func_definition){complete_network <- complete_network[ which(is.na(complete_network["func_defined"])) , ] }
# take again original files for adding the path where a func' is defined
origines_files <- unique(fn_network[which(!is.na(fn_network$func_defined)), c("func_defined","file_path", "content")])
colnames( origines_files ) <- c("function", "defined_in", "definition_content")
complete_network <- merge(complete_network, origines_files, by.x = "called_name", by.y = "function", all.x = TRUE)
returned_network <- complete_network[, c("file_path", "defined_in", "called_name", "line_number", "content",  "definition_content")]
if(filter_ego_link){returned_network <- returned_network[ which( returned_network["file_path"] != returned_network["defined_in"]) , ] }
returned_network <- returned_network[-grep(x = returned_network$file_path, pattern =  regex_to_exclude_files_path), ]
return(returned_network)
}
test <- get_text_network_from_files()
grep(x = returned_network$file_path, pattern =  regex_to_exclude_files_path)
grep(x = c("aaaa", "bbb", 'ccc'), pattern =  "test-")
grep(x = c("aaaa", "bbb", 'ccc'), pattern =  "")
get_text_network_from_files <- function(functions_folder_path = getwd()
, filter_match_by_nchar = 3
, filter_func_name_not_in = "" #c("server")
,  suffix_for_regex_from_the_text = ""
,prefix_for_regex_from_the_text = ""
, regex_to_exclude_files_path = "test-"
, filter_matched_line = T
, filter_func_definition = T
, filter_ego_link = T
){
####1) Get content from R files ####
# With the default regex of srch_pattern_in_files_get_df, fn_network indicate where the func' are defined
fn_network <-  srch_pattern_in_files_get_df(path_main_folder = functions_folder_path
, file_path_col_name = "file_path", content_col_name = "content", extracted_prefix_col_name = "func_defined")
fn_defined <- unique(fn_network$func_defined)
#we have the files where each func is defined
fn_defined <- fn_defined[!fn_defined %in% filter_func_name_not_in]
#### 2) Constructing regex ####
regexx <- fn_defined[!is.na(fn_defined)]
# with name of func we will construct a regex pattern, passed to extract_txt_from_df_vars
# filter result according to nchar parameter =>
regexx <- regexx[which(nchar(regexx) > filter_match_by_nchar)]
# optionnally add a suffix (such as a filter from the user)
regexx <- paste0(prefix_for_regex_from_the_text, regexx, suffix_for_regex_from_the_text)
# made a single giga-regex and clean it from unescaped chars
regexx_complete <- paste0(regexx, collapse = "|")
# clean undesired char
regexx_complete <- escape_unescaped_chars(regexx_complete)
#### 3) get network of func' ####
# Extract text again from the content, again (but dynamic regex)
complete_network <- extract_txt_from_df_vars(df = fn_network, regex_extract_txt = regexx_complete
, cols_for_searching_text = "content", returned_col_name = "called_name", keep_empty_results = F) # matches are func' CALLED
#### 4) filter the network ####
# we have the ego-network remaining from where the file is defined, counting as a link for now
if(filter_matched_line){complete_network <- complete_network[ which(!is.na(complete_network["called_name"])) , ] }
# not empty func_defined value indicate that this is a function definition (from the begining => ego-link or even recursivity)
if(filter_func_definition){complete_network <- complete_network[ which(is.na(complete_network["func_defined"])) , ] }
# take again original files for adding the path where a func' is defined
origines_files <- unique(fn_network[which(!is.na(fn_network$func_defined)), c("func_defined","file_path", "content")])
colnames( origines_files ) <- c("function", "defined_in", "definition_content")
complete_network <- merge(complete_network, origines_files, by.x = "called_name", by.y = "function", all.x = TRUE)
returned_network <- complete_network[, c("file_path", "defined_in", "called_name", "line_number", "content",  "definition_content")]
if(filter_ego_link){returned_network <- returned_network[ which( returned_network["file_path"] != returned_network["defined_in"]) , ] }
# filter if user want to filter
path_to_filter <- grep(x = returned_network$file_path, pattern =  regex_to_exclude_files_path)
returned_network <- returned_network[-path_to_filter, ]
return(returned_network)
}
test <- get_text_network_from_files()
View(test)
test <- get_text_network_from_files(regex_to_exclude_files_path = "")
test <- get_text_network_from_files(regex_to_exclude_files_path = ".*")
test <- get_text_network_from_files(regex_to_exclude_files_path = "")
test <- get_text_network_from_files(regex_to_exclude_files_path = NULL)
get_text_network_from_files <- function(functions_folder_path = getwd()
, filter_match_by_nchar = 3
, filter_func_name_not_in = "" #c("server")
,  suffix_for_regex_from_the_text = ""
,prefix_for_regex_from_the_text = ""
, regex_to_exclude_files_path = NULL #"test-"
, filter_matched_line = T
, filter_func_definition = T
, filter_ego_link = T
){
####1) Get content from R files ####
# With the default regex of srch_pattern_in_files_get_df, fn_network indicate where the func' are defined
fn_network <-  srch_pattern_in_files_get_df(path_main_folder = functions_folder_path
, file_path_col_name = "file_path", content_col_name = "content", extracted_prefix_col_name = "func_defined")
fn_defined <- unique(fn_network$func_defined)
#we have the files where each func is defined
fn_defined <- fn_defined[!fn_defined %in% filter_func_name_not_in]
#### 2) Constructing regex ####
regexx <- fn_defined[!is.na(fn_defined)]
# with name of func we will construct a regex pattern, passed to extract_txt_from_df_vars
# filter result according to nchar parameter =>
regexx <- regexx[which(nchar(regexx) > filter_match_by_nchar)]
# optionnally add a suffix (such as a filter from the user)
regexx <- paste0(prefix_for_regex_from_the_text, regexx, suffix_for_regex_from_the_text)
# made a single giga-regex and clean it from unescaped chars
regexx_complete <- paste0(regexx, collapse = "|")
# clean undesired char
regexx_complete <- escape_unescaped_chars(regexx_complete)
#### 3) get network of func' ####
# Extract text again from the content, again (but dynamic regex)
complete_network <- extract_txt_from_df_vars(df = fn_network, regex_extract_txt = regexx_complete
, cols_for_searching_text = "content", returned_col_name = "called_name", keep_empty_results = F) # matches are func' CALLED
#### 4) filter the network ####
# we have the ego-network remaining from where the file is defined, counting as a link for now
if(filter_matched_line){complete_network <- complete_network[ which(!is.na(complete_network["called_name"])) , ] }
# not empty func_defined value indicate that this is a function definition (from the begining => ego-link or even recursivity)
if(filter_func_definition){complete_network <- complete_network[ which(is.na(complete_network["func_defined"])) , ] }
# take again original files for adding the path where a func' is defined
origines_files <- unique(fn_network[which(!is.na(fn_network$func_defined)), c("func_defined","file_path", "content")])
colnames( origines_files ) <- c("function", "defined_in", "definition_content")
complete_network <- merge(complete_network, origines_files, by.x = "called_name", by.y = "function", all.x = TRUE)
returned_network <- complete_network[, c("file_path", "defined_in", "called_name", "line_number", "content",  "definition_content")]
if(filter_ego_link){returned_network <- returned_network[ which( returned_network["file_path"] != returned_network["defined_in"]) , ] }
# filter if user want to filter
if(!is.null(regex_to_exclude_files_path)){
returned_network <-  returned_network[-grep(x = returned_network$file_path, pattern =  regex_to_exclude_files_path) , ]
}
return(returned_network)
}
test <- get_text_network_from_files(regex_to_exclude_files_path = NULL)
View(test)
test <- get_text_network_from_files(regex_to_exclude_files_path = "test\\-")
test <- get_text_network_from_files(regex_to_exclude_files_path = "test-")
View(test)
