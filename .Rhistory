# we have the ego-network remaining from where the file is defined, counting as a link for now
if(filter_matched_line){complete_network <- complete_network[ which(!is.na(complete_network["to"])) , ] }
complete_network <- complete_network[ which(!is.na(complete_network["to"])) , ]
complete_network
#### 3) get network of func' ####
# Extract text again from the content, again (but dynamic regex)
complete_network <- extract_txt_from_df_vars(df = fn_network, regex_extract_txt = regexx_complete, cols_for_searching_text = "content", returned_col_name = "to", keep_empty_results = F)
complete_network
complete_network
fn_network
complete_network
View(fn_network)
complete_network
fn_network
View(complete_network)
View(complete_network)
####1) Get content from R files ####
# With the default regex of srch_pattern_in_files_get_df, fn_network indicate where the func' are defined
fn_network <-  srch_pattern_in_files_get_df(path_main_folder = functions_folder_path, file_path_col_name = "file_path", content_col_name = "content", extracted_prefix_col_name = "func_defined")
fn_defined <- unique(fn_network$matches)
#### 2) Constructing regex ####
regexx <- fn_defined[!is.na(fn_defined)]
fn_network
fn_defined <- unique(fn_network$func_defined)
#### 2) Constructing regex ####
regexx <- fn_defined[!is.na(fn_defined)]
# filter result according to nchar parameter =>
regexx <- regexx[which(nchar(regexx) > filter_match_by_nchar)]
# optionnally add a suffix (such as a filter from the user)
regexx <- paste0(regexx, suffix_for_regex_from_the_text)
# made a single giga-regex and clean it from unescaped chars
regexx_complete <- paste0(regexx, collapse = "|")
# clean undesired char
regexx_complete <- escape_unescaped_chars(regexx_complete)
#### 3) get network of func' ####
# Extract text again from the content, again (but dynamic regex)
complete_network <- extract_txt_from_df_vars(df = fn_network, regex_extract_txt = regexx_complete, cols_for_searching_text = "content", returned_col_name = "to", keep_empty_results = F)
complete_network <- complete_network[ which(!is.na(complete_network["to"])) , ]
fn_network
complete_network[ which(!is.na(complete_network["to"])) , ]
complete_network[ which(!is.na(complete_network["func_defined"])) , ]
complete_network[ which(is.na(complete_network["func_defined"])) , ]
#### 3) get network of func' ####
# Extract text again from the content, again (but dynamic regex)
complete_network <- extract_txt_from_df_vars(df = fn_network, regex_extract_txt = regexx_complete, cols_for_searching_text = "content", returned_col_name = "from", keep_empty_results = F)
complete_network <- complete_network[ which(!is.na(complete_network["from"])) , ]
complete_network[ which(is.na(complete_network["func_defined"])) , ]
####1) Get content from R files ####
# With the default regex of srch_pattern_in_files_get_df, fn_network indicate where the func' are defined
fn_network <-  srch_pattern_in_files_get_df(path_main_folder = functions_folder_path, file_path_col_name = "file_path", content_col_name = "content", extracted_prefix_col_name = "func_defined")
fn_defined <- unique(fn_network$func_defined)
#### 2) Constructing regex ####
regexx <- fn_defined[!is.na(fn_defined)]
# filter result according to nchar parameter =>
regexx <- regexx[which(nchar(regexx) > filter_match_by_nchar)]
# optionnally add a suffix (such as a filter from the user)
regexx <- paste0(regexx, suffix_for_regex_from_the_text)
# made a single giga-regex and clean it from unescaped chars
regexx_complete <- paste0(regexx, collapse = "|")
# clean undesired char
regexx_complete <- escape_unescaped_chars(regexx_complete)
#### 3) get network of func' ####
# Extract text again from the content, again (but dynamic regex)
complete_network <- extract_txt_from_df_vars(df = fn_network, regex_extract_txt = regexx_complete
, cols_for_searching_text = "content", returned_col_name = "to", keep_empty_results = F) # in the end these matches are func' CALLED
# we have the ego-network remaining from where the file is defined, counting as a link for now
if(filter_matched_line){complete_network <- complete_network[ which(!is.na(complete_network["to"])) , ] }
complete_network[ which(!is.na(complete_network["to"])) , ]
complete_network <- complete_network[ which(!is.na(complete_network["to"])) , ]
complete_network[ which(is.na(complete_network["func_defined"])) , ]
fn_network[, c("func_defined","to")]
fn_network[, c("func_defined","file_path")]
unique(fn_network[, c("func_defined","file_path")])
origines_files <- unique(fn_network[, c("func_defined","file_path")])
origines_files[[1]]
origines_files[which(!is.na(origines_files[[1]]))]
is.na(origines_files[[1]])
which(!is.na(origines_files[[1]]))
origines_files[, which(!is.na(origines_files[[1]]))]
which(!is.na(origines_files[[1]]))
origines_files[[which(!is.na(origines_files[[1]]))]]
origines_files[[1]]
which(!is.na(origines_files[[1]]))
origines_files[which(!is.na(origines_files[[1]])), ]
fn_network
origines_files <- unique(fn_network[which(!is.na(fn_network$func_defined)), c("func_defined","file_path")])
test <- merge( complete_network, origines_files, by.x = "to", by.y = "func_defined", all.x = TRUE)
View(test)
####1) Get content from R files ####
# With the default regex of srch_pattern_in_files_get_df, fn_network indicate where the func' are defined
fn_network <-  srch_pattern_in_files_get_df(path_main_folder = functions_folder_path, file_path_col_name = "file_path_defined", content_col_name = "content", extracted_prefix_col_name = "func_defined")
fn_defined <- unique(fn_network$func_defined)
#### 2) Constructing regex ####
regexx <- fn_defined[!is.na(fn_defined)]
# filter result according to nchar parameter =>
regexx <- regexx[which(nchar(regexx) > filter_match_by_nchar)]
# optionnally add a suffix (such as a filter from the user)
regexx <- paste0(regexx, suffix_for_regex_from_the_text)
# made a single giga-regex and clean it from unescaped chars
regexx_complete <- paste0(regexx, collapse = "|")
# clean undesired char
regexx_complete <- escape_unescaped_chars(regexx_complete)
#### 3) get network of func' ####
# Extract text again from the content, again (but dynamic regex)
complete_network <- extract_txt_from_df_vars(df = fn_network, regex_extract_txt = regexx_complete
, cols_for_searching_text = "content", returned_col_name = "to_name", keep_empty_results = F) # matches are func' CALLED
complete_network <- complete_network[ which(!is.na(complete_network["to_name"])) , ]
complete_network <- complete_network[ which(is.na(complete_network["func_defined"])) , ]
origines_files <- unique(fn_network[which(!is.na(fn_network$func_defined)), c("func_defined","file_path")])
test <- merge( complete_network, origines_files, by.x = "to", by.y = "func_defined", all.x = TRUE)
origines_files <- unique(fn_network[which(!is.na(fn_network$func_defined)), c("func_defined","file_path_defined")])
test <- merge( complete_network, origines_files, by.x = "to", by.y = "func_defined", all.x = TRUE)
test <- merge( complete_network, origines_files, by.x = "to_name", by.y = "func_defined", all.x = TRUE)
View(test)
origines_files
#### 3) get network of func' ####
# Extract text again from the content, again (but dynamic regex)
complete_network <- extract_txt_from_df_vars(df = fn_network, regex_extract_txt = regexx_complete
, cols_for_searching_text = "content", returned_col_name = "to_name", keep_empty_results = F) # matches are func' CALLED
complete_network <- complete_network[ which(!is.na(complete_network["to_name"])) , ]
complete_network <- complete_network[ which(is.na(complete_network["func_defined"])) , ]
origines_files <- unique(fn_network[which(!is.na(fn_network$func_defined)), c("func_defined","file_path_defined")])
origines_files
colnames(original_files  ) <- c("function", "defined_ind")
colnames(original_files  ) <- c("function", "defined_in")
test <- merge( complete_network, origines_files, by.x = "to_name", by.y = "function", all.x = TRUE)
View(test)
original_files
origines_files <- unique(fn_network[which(!is.na(fn_network$func_defined)), c("func_defined","file_path_defined")])
colnames(original_files  ) <- c("function", "defined_in")
origines_files
colnames(original_files  )
colnames( origines_files  ) <- c("function", "defined_in")
test <- merge( complete_network, origines_files, by.x = "to_name", by.y = "function", all.x = TRUE)
#### 3) get network of func' ####
# Extract text again from the content, again (but dynamic regex)
complete_network <- extract_txt_from_df_vars(df = fn_network, regex_extract_txt = regexx_complete
, cols_for_searching_text = "content", returned_col_name = "to_name", keep_empty_results = F) # matches are func' CALLED
# we have the ego-network remaining from where the file is defined, counting as a link for now
if(filter_matched_line){complete_network <- complete_network[ which(!is.na(complete_network["to_name"])) , ] }
# not empty func_defined value indicate that this is a function definition (from the begining => ego-link or even recursivity)
if(filter_func_definition){complete_network <- complete_network[ which(is.na(complete_network["func_defined"])) , ] }
filter_matched_line = T
# we have the ego-network remaining from where the file is defined, counting as a link for now
if(filter_matched_line){complete_network <- complete_network[ which(!is.na(complete_network["to_name"])) , ] }
# not empty func_defined value indicate that this is a function definition (from the begining => ego-link or even recursivity)
if(filter_func_definition){complete_network <- complete_network[ which(is.na(complete_network["func_defined"])) , ] }
filter_func_definition = T
# not empty func_defined value indicate that this is a function definition (from the begining => ego-link or even recursivity)
if(filter_func_definition){complete_network <- complete_network[ which(is.na(complete_network["func_defined"])) , ] }
origines_files <- unique(fn_network[which(!is.na(fn_network$func_defined)), c("func_defined","file_path_defined")])
colnames( origines_files  ) <- c("function", "defined_in")
test <- merge( complete_network, origines_files, by.x = "to_name", by.y = "function", all.x = TRUE)
complete_network <- complete_network[ which( complete_network["to"] != complete_network["from"]) , ]
View(test)
complete_network <- complete_network[ which(is.na(complete_network["func_defined"])) , ]
origines_files
####1) Get content from R files ####
# With the default regex of srch_pattern_in_files_get_df, fn_network indicate where the func' are defined
fn_network <-  srch_pattern_in_files_get_df(path_main_folder = functions_folder_path
, file_path_col_name = "file_path", content_col_name = "content", extracted_prefix_col_name = "func_defined")
fn_defined <- unique(fn_network$func_defined)
#### 2) Constructing regex ####
regexx <- fn_defined[!is.na(fn_defined)]
# filter result according to nchar parameter =>
regexx <- regexx[which(nchar(regexx) > filter_match_by_nchar)]
# optionnally add a suffix (such as a filter from the user)
regexx <- paste0(regexx, suffix_for_regex_from_the_text)
# made a single giga-regex and clean it from unescaped chars
regexx_complete <- paste0(regexx, collapse = "|")
# clean undesired char
regexx_complete <- escape_unescaped_chars(regexx_complete)
#### 3) get network of func' ####
# Extract text again from the content, again (but dynamic regex)
complete_network <- extract_txt_from_df_vars(df = fn_network, regex_extract_txt = regexx_complete
, cols_for_searching_text = "content", returned_col_name = "to_name", keep_empty_results = F) # matches are func' CALLED
#### 3) get network of func' ####
# Extract text again from the content, again (but dynamic regex)
complete_network <- extract_txt_from_df_vars(df = fn_network, regex_extract_txt = regexx_complete
, cols_for_searching_text = "content", returned_col_name = "called", keep_empty_results = F) # matches are func' CALLED
#### 3) get network of func' ####
# Extract text again from the content, again (but dynamic regex)
complete_network <- extract_txt_from_df_vars(df = fn_network, regex_extract_txt = regexx_complete
, cols_for_searching_text = "content", returned_col_name = "called_name", keep_empty_results = F) # matches are func' CALLED
#### 4) filter the network ####
# we have the ego-network remaining from where the file is defined, counting as a link for now
if(filter_matched_line){complete_network <- complete_network[ which(!is.na(complete_network["called_name"])) , ] }
# not empty func_defined value indicate that this is a function definition (from the begining => ego-link or even recursivity)
if(filter_func_definition){complete_network <- complete_network[ which(is.na(complete_network["func_defined"])) , ] }
origines_files <- unique(fn_network[which(!is.na(fn_network$func_defined)), c("func_defined","file_path_defined")])
colnames( origines_files  ) <- c("function", "defined_in")
origines_files
merge( complete_network, origines_files, by.x = "called_name", by.y = "function", all.x = TRUE)
test <- merge( complete_network, origines_files, by.x = "called_name", by.y = "function", all.x = TRUE)
View(test)
View(test)
View(test)
complete_network <- merge( complete_network, origines_files, by.x = "called_name", by.y = "function", all.x = TRUE)
returned_network <- complete_network[, c("file_path", "defined_in", "line_number", "called_name", "content",)]
returned_network <- complete_network[, c("file_path", "defined_in", "line_number", "called_name", "content")]
returned_network[ which( returned_network["file_path"] != returned_network["defined_in"]) , ]
returned_network <- returned_network[ which( returned_network["file_path"] != returned_network["defined_in"]) , ]
get_text_network_from_files <- function(functions_folder_path = getwd()
, filter_match_by_nchar = 3
,  suffix_for_regex_from_the_text = ""
, erase_func = ""
, filter_matched_line = T
, filter_func_definition = T
, filter_ego_link = T
){
####1) Get content from R files ####
# With the default regex of srch_pattern_in_files_get_df, fn_network indicate where the func' are defined
fn_network <-  srch_pattern_in_files_get_df(path_main_folder = functions_folder_path
, file_path_col_name = "file_path", content_col_name = "content", extracted_prefix_col_name = "func_defined")
fn_defined <- unique(fn_network$func_defined)
#we have the files where each func is defined
#### 2) Constructing regex ####
regexx <- fn_defined[!is.na(fn_defined)]
# with name of func we will construct a regex pattern, passed to extract_txt_from_df_vars
# filter result according to nchar parameter =>
regexx <- regexx[which(nchar(regexx) > filter_match_by_nchar)]
# optionnally add a suffix (such as a filter from the user)
regexx <- paste0(regexx, suffix_for_regex_from_the_text)
# made a single giga-regex and clean it from unescaped chars
regexx_complete <- paste0(regexx, collapse = "|")
# clean undesired char
regexx_complete <- escape_unescaped_chars(regexx_complete)
#### 3) get network of func' ####
# Extract text again from the content, again (but dynamic regex)
complete_network <- extract_txt_from_df_vars(df = fn_network, regex_extract_txt = regexx_complete
, cols_for_searching_text = "content", returned_col_name = "called_name", keep_empty_results = F) # matches are func' CALLED
#### 4) filter the network ####
# we have the ego-network remaining from where the file is defined, counting as a link for now
if(filter_matched_line){complete_network <- complete_network[ which(!is.na(complete_network["called_name"])) , ] }
# not empty func_defined value indicate that this is a function definition (from the begining => ego-link or even recursivity)
if(filter_func_definition){complete_network <- complete_network[ which(is.na(complete_network["func_defined"])) , ] }
origines_files <- unique(fn_network[which(!is.na(fn_network$func_defined)), c("func_defined","file_path_defined")])
colnames( origines_files  ) <- c("function", "defined_in")
complete_network <- merge( complete_network, origines_files, by.x = "called_name", by.y = "function", all.x = TRUE)
returned_network <- complete_network[, c("file_path", "defined_in", "called_name", "line_number", "content")]
if(filter_ego_link){returned_network <- returned_network[ which( returned_network["file_path"] != returned_network["defined_in"]) , ] }
return(returned_network)
}
test <- get_text_network_from_files()
get_text_network_from_files <- function(functions_folder_path = getwd()
, filter_match_by_nchar = 3
,  suffix_for_regex_from_the_text = ""
, erase_func = ""
, filter_matched_line = T
, filter_func_definition = T
, filter_ego_link = T
){
####1) Get content from R files ####
# With the default regex of srch_pattern_in_files_get_df, fn_network indicate where the func' are defined
fn_network <-  srch_pattern_in_files_get_df(path_main_folder = functions_folder_path
, file_path_col_name = "file_path", content_col_name = "content", extracted_prefix_col_name = "func_defined")
fn_defined <- unique(fn_network$func_defined)
#we have the files where each func is defined
#### 2) Constructing regex ####
regexx <- fn_defined[!is.na(fn_defined)]
# with name of func we will construct a regex pattern, passed to extract_txt_from_df_vars
# filter result according to nchar parameter =>
regexx <- regexx[which(nchar(regexx) > filter_match_by_nchar)]
# optionnally add a suffix (such as a filter from the user)
regexx <- paste0(regexx, suffix_for_regex_from_the_text)
# made a single giga-regex and clean it from unescaped chars
regexx_complete <- paste0(regexx, collapse = "|")
# clean undesired char
regexx_complete <- escape_unescaped_chars(regexx_complete)
#### 3) get network of func' ####
# Extract text again from the content, again (but dynamic regex)
complete_network <- extract_txt_from_df_vars(df = fn_network, regex_extract_txt = regexx_complete
, cols_for_searching_text = "content", returned_col_name = "called_name", keep_empty_results = F) # matches are func' CALLED
#### 4) filter the network ####
# we have the ego-network remaining from where the file is defined, counting as a link for now
if(filter_matched_line){complete_network <- complete_network[ which(!is.na(complete_network["called_name"])) , ] }
# not empty func_defined value indicate that this is a function definition (from the begining => ego-link or even recursivity)
if(filter_func_definition){complete_network <- complete_network[ which(is.na(complete_network["func_defined"])) , ] }
origines_files <- unique(fn_network[which(!is.na(fn_network$func_defined)), c("func_defined","file_path")])
colnames( origines_files  ) <- c("function", "defined_in")
complete_network <- merge( complete_network, origines_files, by.x = "called_name", by.y = "function", all.x = TRUE)
returned_network <- complete_network[, c("file_path", "defined_in", "called_name", "line_number", "content")]
if(filter_ego_link){returned_network <- returned_network[ which( returned_network["file_path"] != returned_network["defined_in"]) , ] }
return(returned_network)
}
test <- get_text_network_from_files()
View(test)
View(test)
library(codexplor)
require(codexplor)
code*
get_text_network_from_files <- function(functions_folder_path = getwd()
, filter_match_by_nchar = 3
,  suffix_for_regex_from_the_text = ""
, filter_matched_line = T
, filter_func_definition = T
, filter_ego_link = T
){
####1) Get content from R files ####
# With the default regex of srch_pattern_in_files_get_df, fn_network indicate where the func' are defined
fn_network <-  srch_pattern_in_files_get_df(path_main_folder = functions_folder_path
, file_path_col_name = "file_path", content_col_name = "content", extracted_prefix_col_name = "func_defined")
fn_defined <- unique(fn_network$func_defined)
#we have the files where each func is defined
#### 2) Constructing regex ####
regexx <- fn_defined[!is.na(fn_defined)]
# with name of func we will construct a regex pattern, passed to extract_txt_from_df_vars
# filter result according to nchar parameter =>
regexx <- regexx[which(nchar(regexx) > filter_match_by_nchar)]
# optionnally add a suffix (such as a filter from the user)
regexx <- paste0(regexx, suffix_for_regex_from_the_text)
# made a single giga-regex and clean it from unescaped chars
regexx_complete <- paste0(regexx, collapse = "|")
# clean undesired char
regexx_complete <- escape_unescaped_chars(regexx_complete)
#### 3) get network of func' ####
# Extract text again from the content, again (but dynamic regex)
complete_network <- extract_txt_from_df_vars(df = fn_network, regex_extract_txt = regexx_complete
, cols_for_searching_text = "content", returned_col_name = "called_name", keep_empty_results = F) # matches are func' CALLED
#### 4) filter the network ####
# we have the ego-network remaining from where the file is defined, counting as a link for now
if(filter_matched_line){complete_network <- complete_network[ which(!is.na(complete_network["called_name"])) , ] }
# not empty func_defined value indicate that this is a function definition (from the begining => ego-link or even recursivity)
if(filter_func_definition){complete_network <- complete_network[ which(is.na(complete_network["func_defined"])) , ] }
origines_files <- unique(fn_network[which(!is.na(fn_network$func_defined)), c("func_defined","file_path")])
colnames( origines_files  ) <- c("function", "defined_in")
complete_network <- merge( complete_network, origines_files, by.x = "called_name", by.y = "function", all.x = TRUE)
returned_network <- complete_network[, c("file_path", "defined_in", "called_name", "line_number", "content")]
if(filter_ego_link){returned_network <- returned_network[ which( returned_network["file_path"] != returned_network["defined_in"]) , ] }
return(returned_network)
}
get_text_network_from_files("~")
test <-get_text_network_from_files("~")
View(test)
origines_files <- unique(fn_network[which(!is.na(fn_network$func_defined)), c("func_defined","file_path", "content")])
colnames( origines_files  ) <- c("function", "defined_in", "definition_content")
get_text_network_from_files <- function(functions_folder_path = getwd()
, filter_match_by_nchar = 3
,  suffix_for_regex_from_the_text = ""
, filter_matched_line = T
, filter_func_definition = T
, filter_ego_link = T
){
####1) Get content from R files ####
# With the default regex of srch_pattern_in_files_get_df, fn_network indicate where the func' are defined
fn_network <-  srch_pattern_in_files_get_df(path_main_folder = functions_folder_path
, file_path_col_name = "file_path", content_col_name = "content", extracted_prefix_col_name = "func_defined")
fn_defined <- unique(fn_network$func_defined)
#we have the files where each func is defined
#### 2) Constructing regex ####
regexx <- fn_defined[!is.na(fn_defined)]
# with name of func we will construct a regex pattern, passed to extract_txt_from_df_vars
# filter result according to nchar parameter =>
regexx <- regexx[which(nchar(regexx) > filter_match_by_nchar)]
# optionnally add a suffix (such as a filter from the user)
regexx <- paste0(regexx, suffix_for_regex_from_the_text)
# made a single giga-regex and clean it from unescaped chars
regexx_complete <- paste0(regexx, collapse = "|")
# clean undesired char
regexx_complete <- escape_unescaped_chars(regexx_complete)
#### 3) get network of func' ####
# Extract text again from the content, again (but dynamic regex)
complete_network <- extract_txt_from_df_vars(df = fn_network, regex_extract_txt = regexx_complete
, cols_for_searching_text = "content", returned_col_name = "called_name", keep_empty_results = F) # matches are func' CALLED
#### 4) filter the network ####
# we have the ego-network remaining from where the file is defined, counting as a link for now
if(filter_matched_line){complete_network <- complete_network[ which(!is.na(complete_network["called_name"])) , ] }
# not empty func_defined value indicate that this is a function definition (from the begining => ego-link or even recursivity)
if(filter_func_definition){complete_network <- complete_network[ which(is.na(complete_network["func_defined"])) , ] }
origines_files <- unique(fn_network[which(!is.na(fn_network$func_defined)), c("func_defined","file_path", "content")])
colnames( origines_files  ) <- c("function", "defined_in", "definition_content")
complete_network <- merge( complete_network, origines_files, by.x = "called_name", by.y = "function", all.x = TRUE)
returned_network <- complete_network[, c("file_path", "defined_in", "called_name", "line_number", "content")]
if(filter_ego_link){returned_network <- returned_network[ which( returned_network["file_path"] != returned_network["defined_in"]) , ] }
return(returned_network)
}
test <-get_text_network_from_files("~")
View(test)
View(test)
get_text_network_from_files <- function(functions_folder_path = getwd()
, filter_match_by_nchar = 3
,  suffix_for_regex_from_the_text = ""
, filter_matched_line = T
, filter_func_definition = T
, filter_ego_link = T
){
####1) Get content from R files ####
# With the default regex of srch_pattern_in_files_get_df, fn_network indicate where the func' are defined
fn_network <-  srch_pattern_in_files_get_df(path_main_folder = functions_folder_path
, file_path_col_name = "file_path", content_col_name = "content", extracted_prefix_col_name = "func_defined")
fn_defined <- unique(fn_network$func_defined)
#we have the files where each func is defined
#### 2) Constructing regex ####
regexx <- fn_defined[!is.na(fn_defined)]
# with name of func we will construct a regex pattern, passed to extract_txt_from_df_vars
# filter result according to nchar parameter =>
regexx <- regexx[which(nchar(regexx) > filter_match_by_nchar)]
# optionnally add a suffix (such as a filter from the user)
regexx <- paste0(regexx, suffix_for_regex_from_the_text)
# made a single giga-regex and clean it from unescaped chars
regexx_complete <- paste0(regexx, collapse = "|")
# clean undesired char
regexx_complete <- escape_unescaped_chars(regexx_complete)
#### 3) get network of func' ####
# Extract text again from the content, again (but dynamic regex)
complete_network <- extract_txt_from_df_vars(df = fn_network, regex_extract_txt = regexx_complete
, cols_for_searching_text = "content", returned_col_name = "called_name", keep_empty_results = F) # matches are func' CALLED
#### 4) filter the network ####
# we have the ego-network remaining from where the file is defined, counting as a link for now
if(filter_matched_line){complete_network <- complete_network[ which(!is.na(complete_network["called_name"])) , ] }
# not empty func_defined value indicate that this is a function definition (from the begining => ego-link or even recursivity)
if(filter_func_definition){complete_network <- complete_network[ which(is.na(complete_network["func_defined"])) , ] }
origines_files <- unique(fn_network[which(!is.na(fn_network$func_defined)), c("func_defined","file_path", "content")])
colnames( origines_files  ) <- c("function", "defined_in", "definition_content")
complete_network <- merge( complete_network, origines_files, by.x = "called_name", by.y = "function", all.x = TRUE)
returned_network <- complete_network[, c("file_path", "defined_in", "called_name", "line_number", "content",  "definition_content")]
if(filter_ego_link){returned_network <- returned_network[ which( returned_network["file_path"] != returned_network["defined_in"]) , ] }
return(returned_network)
}
test <-get_text_network_from_files("~")
fn_defined
fn_defined
get_text_network_from_files <- function(functions_folder_path = getwd()
, filter_match_by_nchar = 3
, filter_func_name_not_in = c("server")
,  suffix_for_regex_from_the_text = ""
, filter_matched_line = T
, filter_func_definition = T
, filter_ego_link = T
){
####1) Get content from R files ####
# With the default regex of srch_pattern_in_files_get_df, fn_network indicate where the func' are defined
fn_network <-  srch_pattern_in_files_get_df(path_main_folder = functions_folder_path
, file_path_col_name = "file_path", content_col_name = "content", extracted_prefix_col_name = "func_defined")
fn_defined <- unique(fn_network$func_defined)
#we have the files where each func is defined
fn_defined <- fn_defined %notin% filter_func_name_not_in
#### 2) Constructing regex ####
regexx <- fn_defined[!is.na(fn_defined)]
# with name of func we will construct a regex pattern, passed to extract_txt_from_df_vars
# filter result according to nchar parameter =>
regexx <- regexx[which(nchar(regexx) > filter_match_by_nchar)]
# optionnally add a suffix (such as a filter from the user)
regexx <- paste0(regexx, suffix_for_regex_from_the_text)
# made a single giga-regex and clean it from unescaped chars
regexx_complete <- paste0(regexx, collapse = "|")
# clean undesired char
regexx_complete <- escape_unescaped_chars(regexx_complete)
#### 3) get network of func' ####
# Extract text again from the content, again (but dynamic regex)
complete_network <- extract_txt_from_df_vars(df = fn_network, regex_extract_txt = regexx_complete
, cols_for_searching_text = "content", returned_col_name = "called_name", keep_empty_results = F) # matches are func' CALLED
#### 4) filter the network ####
# we have the ego-network remaining from where the file is defined, counting as a link for now
if(filter_matched_line){complete_network <- complete_network[ which(!is.na(complete_network["called_name"])) , ] }
# not empty func_defined value indicate that this is a function definition (from the begining => ego-link or even recursivity)
if(filter_func_definition){complete_network <- complete_network[ which(is.na(complete_network["func_defined"])) , ] }
origines_files <- unique(fn_network[which(!is.na(fn_network$func_defined)), c("func_defined","file_path", "content")])
colnames( origines_files  ) <- c("function", "defined_in", "definition_content")
complete_network <- merge( complete_network, origines_files, by.x = "called_name", by.y = "function", all.x = TRUE)
returned_network <- complete_network[, c("file_path", "defined_in", "called_name", "line_number", "content",  "definition_content")]
if(filter_ego_link){returned_network <- returned_network[ which( returned_network["file_path"] != returned_network["defined_in"]) , ] }
return(returned_network)
}
test <-get_text_network_from_files("~")
fn_defined[!fn_defined %in% filter_func_name_not_in]
filter_func_name_not_in = c("server")
fn_defined[!fn_defined %in% filter_func_name_not_in]
get_text_network_from_files <- function(functions_folder_path = getwd()
, filter_match_by_nchar = 3
, filter_func_name_not_in = c("server")
,  suffix_for_regex_from_the_text = ""
, filter_matched_line = T
, filter_func_definition = T
, filter_ego_link = T
){
####1) Get content from R files ####
# With the default regex of srch_pattern_in_files_get_df, fn_network indicate where the func' are defined
fn_network <-  srch_pattern_in_files_get_df(path_main_folder = functions_folder_path
, file_path_col_name = "file_path", content_col_name = "content", extracted_prefix_col_name = "func_defined")
fn_defined <- unique(fn_network$func_defined)
#we have the files where each func is defined
fn_defined <- fn_defined[!fn_defined %in% filter_func_name_not_in]
#### 2) Constructing regex ####
regexx <- fn_defined[!is.na(fn_defined)]
# with name of func we will construct a regex pattern, passed to extract_txt_from_df_vars
# filter result according to nchar parameter =>
regexx <- regexx[which(nchar(regexx) > filter_match_by_nchar)]
# optionnally add a suffix (such as a filter from the user)
regexx <- paste0(regexx, suffix_for_regex_from_the_text)
# made a single giga-regex and clean it from unescaped chars
regexx_complete <- paste0(regexx, collapse = "|")
# clean undesired char
regexx_complete <- escape_unescaped_chars(regexx_complete)
#### 3) get network of func' ####
# Extract text again from the content, again (but dynamic regex)
complete_network <- extract_txt_from_df_vars(df = fn_network, regex_extract_txt = regexx_complete
, cols_for_searching_text = "content", returned_col_name = "called_name", keep_empty_results = F) # matches are func' CALLED
#### 4) filter the network ####
# we have the ego-network remaining from where the file is defined, counting as a link for now
if(filter_matched_line){complete_network <- complete_network[ which(!is.na(complete_network["called_name"])) , ] }
# not empty func_defined value indicate that this is a function definition (from the begining => ego-link or even recursivity)
if(filter_func_definition){complete_network <- complete_network[ which(is.na(complete_network["func_defined"])) , ] }
origines_files <- unique(fn_network[which(!is.na(fn_network$func_defined)), c("func_defined","file_path", "content")])
colnames( origines_files  ) <- c("function", "defined_in", "definition_content")
complete_network <- merge( complete_network, origines_files, by.x = "called_name", by.y = "function", all.x = TRUE)
returned_network <- complete_network[, c("file_path", "defined_in", "called_name", "line_number", "content",  "definition_content")]
if(filter_ego_link){returned_network <- returned_network[ which( returned_network["file_path"] != returned_network["defined_in"]) , ] }
return(returned_network)
}
test <-get_text_network_from_files("~")
View(test)
