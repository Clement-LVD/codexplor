% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/detect_unclosed_chars.R
\name{detect_unclosed_chars}
\alias{detect_unclosed_chars}
\title{Detect Unclosed or Mismatched Characters in Text}
\usage{
detect_unclosed_chars(
  text,
  open_and_close_to_test = c(`(` = ")", `[` = "]", `{` = "}"),
  return_list_of_position = TRUE,
  ignore_escaped = FALSE
)
}
\arguments{
\item{text}{A character vector. Each element is a string in which to detect unclosed or
mismatched characters.}

\item{open_and_close_to_test}{A named character vector where the names represent opening
characters and the values the corresponding closing characters. The default is
\code{c("(" = ")", "[" = "]", "{" = "}")}.}

\item{return_list_of_position}{Logical. If \code{TRUE}, the function returns a vector of
positions where errors occur; if \code{FALSE}, it returns a detailed data frame with columns
\code{char}, \code{pos}, and \code{error}.}

\item{ignore_escaped}{Logical. If \code{TRUE}, the function removes (replaces with a space)
any escaped characters (those preceded by a backslash) before performing the check.}
}
\value{
Either \code{NULL} if no errors are found, a vector of positions (if \code{return_list_of_position}
is \code{TRUE}), or a data frame with error details (if \code{return_list_of_position} is \code{FALSE}).
}
\description{
This function scans through a character string (or vector of strings) to detect
unclosed or mismatched pairs of characters (such as parentheses, brackets, or braces)
as specified by the \code{open_and_close_to_test} parameter. For each occurrence
of an extra closing character or a missing closing for an opening character, the function
records the position (and optionnaly error type and relative char). Optionally, escaped characters can be ignored.
}
\details{
The function works by scanning each text element character-by-character.
For each opening character (as specified by \code{open_and_close_to_test}), it increments a counter
and stores its position. For each closing character, it checks if a matching opening character has been encountered.
If not, it records an error for an extra closing. After scanning, any remaining unmatched opening characters are
reported as missing a closing. If \code{ignore_escaped} is \code{TRUE}, any character preceded by a backslash is
replaced by a space before analysis.
}
\examples{
\dontrun{
# Example with balanced text
detect_unclosed_chars("a(b[c{d}e]f)g")

# Example with an extra closing parenthesis
detect_unclosed_chars("a(b[c{d}e]f))g")

# Example with a missing closing parenthesis
detect_unclosed_chars("a(b[c{d(e}f]g)")

# Example returning detailed error data frame
detect_unclosed_chars("a(b[c{d(e}f]g)", return_list_of_position = FALSE)

# Example ignoring escaped characters:
detect_unclosed_chars("a\\\\(b) c", ignore_escaped = TRUE)
# Will return position of char in the chain
# 4
}
}
