% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/extract_nested_blocks_from_text.R
\name{extract_nested_blocks_from_text}
\alias{extract_nested_blocks_from_text}
\title{Extract Nested Blocks and Assign Group IDs and Deep Levels}
\usage{
extract_nested_blocks_from_text(
  text,
  delims = c(`(` = ")", `[` = "]", `{` = "}"),
  return_text_col = TRUE
)
}
\arguments{
\item{text}{\code{character} vector containing one or more text(s)}

\item{delims}{\code{list} of characters symbolizing opening and closing characters, default = \code{c("(" = ")", "[" = "]", "{" = "}")}.}

\item{return_text_col}{\code{logical}, default = \code{FALSE} Return a \code{text} column if set to TRUE}
}
\value{
A data frame with 4 or 5 columns :
\describe{
\item{\code{instruction_id}}{Numeric (row_number)}
\item{\code{block}}{Character (text extracted, surrounded by delimiters)}
\item{\code{level}}{Numeric (level of imbrication of a block surrounded by the delimiters, from \code{1} to \code{Inf})}
\item{\code{group_id.}}{Numeric, symbolize the imbrication within a same block, i.e. surrounded by global delimiters)}
\item{\code{text}}{Original characters vector passed by the user (optionnally returned)}
}
}
\description{
Assuming the user have passed a character vector, this function extracts nested blocks
of text (e.g., Within (Parenth.)), delimited by a specified opening and a closing characters.
It returns a data frame with :
\itemize{
\item the index of the input string ;
\item the extracted block (including delimiters) ;
\item a group_id common to all blocks nested within the same outer block;
\item a deep-level numeric indicator, within the longest block
}
}
\examples{
text <- "Voici un (exemple (avec un texte (imbriquÃ©)) et [un autre exemple]). MAIS ENSUITE (ceci)"
extract_nested_blocks_from_text(text)
}
